package Proyecto;

/* Simple +/-/* expression language; parser evaluates constant expressions on the fly*/
import java_cup.runtime.*;

parser code {:
    // Connect this parser to a scanner!
    Lexer lex;

    @SuppressWarnings("deprecation")
    public parser(Lexer lex){
        this.lex = lex;
        this.symbolFactory = new DefaultSymbolFactory();
    }
:}

/* define how to connect to the scanner! */
init with {: :};
scan with {: return lex.next_token(); :};

/* Terminals (tokens returned by the scanner). */
terminal            BOOL, BREAK, string, INT, FLOAT, CHAR;
terminal            STRING_LITERAL, LBLOQUE, RBLOQUE, STRING;
terminal            SEMI, UMINUS, LPAREN, RPAREN;
terminal            aperturaB, cerraduraB, aperturaC, cerraduraC, aperturaP, cerraduraP, comentarioL;
terminal            comentApert, comentCerrad, finalExpre, True, False;
terminal            letra, ident, caracter, bool;
terminal            menor, mayor, menorIgual, mayorIgual, diferente;
terminal            aumento, equivalente, igual, suma, decremento, multiplicacion, resta, negacion, division, modulo, potencia, conjuncion, disyuncion;
terminal            coma, punto, mainC, forC, doC, whileC, ifC, elseC, elifC, inputC, returnC;
terminal            NUMBER;
terminal            INTEGER_LITERAL;
terminal            FLOAT_LITERAL;

/* Non terminals */
non terminal            expr_list;
non terminal            expr;      // used to store evaluated subexpressions
non terminal tipo, tipoFuncion, tipoNum, operacionArit, operacionLog, operacionRac, lista, tipoArreglo;
non terminal grupoArreglo;


/* Precedences */
precedence left suma, resta;
precedence left multiplicacion;

start with lista;

/* The grammar rules */


expr      ::= expr:e1 suma expr:e2               {: RESULT = e1+"+"+e2; System.out.println(RESULT); :
             | expr:e1 resta expr:e2             {: RESULT = e1+"-"+e2;   System.out.println(RESULT); :}
             | expr:e1 multiplicacion expr:e2    {: RESULT = e1+"*"+e2;     System.out.println(RESULT); :}
             | INTEGER_LITERAL:n	             {: RESULT = n.toString(); System.out.println(RESULT); :}
             ;

lista ::= grupoArreglo (coma grupoArreglo)*;

//arregloSim ::= tipoArreglo id aperturaC numeroE cerraduraC;

grupoArreglo ::= INTEGER_LITERAL
                |FLOAT_LITERAL
                |caracter
                ;
//Agrupaciones
tipo ::= string
        |INT
        |CHAR
        |FLOAT
        |bool
        ;

tipoArreglo := tipoNum 
              |CHAR
              |STRING
              ;

tipoNum ::=  INT
            |FLOAT
            ;
    
tipoFuncion ::=  tipoNum
                |bool
                ;

operacionArit ::= suma 
                |resta 
                |division
                |multiplicacion 
                |modulo 
                |potencia
                ;

operacionRac ::= menor 
                |mayor 
                |menorIgual 
                |mayorIgual 
                |diferente 
                |igual
                ;

operacionLog ::= diferente
                |igual 
                |conjuncion 
                |disyuncion
                ;

