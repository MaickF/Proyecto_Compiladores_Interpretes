package Proyecto;

/* Simple +/-/* expression language; parser evaluates constant expressions on the fly*/
import java_cup.runtime.*;

parser code {:
    // Connect this parser to a scanner!
    Lexer lex;

    @SuppressWarnings("deprecation")
    public parser(Lexer lex){
        this.lex = lex;
        this.symbolFactory = new DefaultSymbolFactory();
    }
:}

/* define how to connect to the scanner! */
init with {: :};
scan with {: return lex.next_token(); :};

/* Terminals (tokens returned by the scanner). */
terminal            BOOL, BREAK, string, INT, FLOAT, CHAR;
terminal            STRING_LITERAL, LBLOQUE, RBLOQUE, STRING;
terminal            SEMI, UMINUS, LPAREN, RPAREN;
terminal            aperturaB, cerraduraB, aperturaC, cerraduraC, aperturaP, cerraduraP, comentarioL;
terminal            comentApert, comentCerrad, finalExpre, True, False;
terminal            letra, ident, caracter, bool;
terminal            menor, mayor, menorIgual, mayorIgual, diferente;
terminal            aumento, equivalente, igual, suma, decremento, multiplicacion, resta, negacion, division, modulo, potencia, conjuncion, disyuncion;
terminal            coma, punto, mainC, forC, doC, whileC, ifC, elseC, elifC, inputC, returnC, printC, inC;
terminal            NUMBER;
terminal            INTEGER_LITERAL;
terminal            FLOAT_LITERAL;

/* Non terminals */
non terminal            expr_list;
non terminal            expr;      // used to store evaluated subexpressions
non terminal tipo, tipoFuncion, tipoNum, operacionArit, operacionLog, operacionRac, lista, tipoArreglo;
non terminal grupoArreglo, arregloSim, arregloAsig, arregloInd;
non terminal returnD, input, print, param, funcionAsig, listaIdent;


/* Precedences */
precedence left suma, resta;
precedence left multiplicacion;

precedence left suma, resta;

precedence left coma;

start with funcionAsig;

/* The grammar rules */


expr      ::= expr:e1 suma expr:e2               {: RESULT = e1+"+"+e2; System.out.println(RESULT); :}
             | expr:e1 resta expr:e2             {: RESULT = e1+"-"+e2;   System.out.println(RESULT); :}
             | expr:e1 multiplicacion expr:e2    {: RESULT = e1+"*"+e2;     System.out.println(RESULT); :}
             | INTEGER_LITERAL:n	             {: RESULT = n.toString(); System.out.println(RESULT); :}
             ;



lista ::= lista:l1 coma lista:l2              {: RESULT = l1+","+l2; System.out.println(RESULT); :}
         |grupoArreglo:n                        {: RESULT = n; System.out.println(RESULT); :}
        ;

grupoArreglo ::= INTEGER_LITERAL {: RESULT = "prueba1"; :}
                |FLOAT_LITERAL {: RESULT = "prueba2"; :}
                |caracter {: RESULT = "prueba3"; :}
                |STRING_LITERAL {: RESULT = "prueba4"; :}
                ;

arregloSim ::= tipoArreglo ident:a aperturaC INTEGER_LITERAL:b cerraduraC  {: RESULT = "tipo "+a+" ["+b.toString()+"]"; System.out.println(RESULT);:}; 

arregloAsig ::= arregloSim:a equivalente aperturaC lista:b cerraduraC {: RESULT = a+" = [" +b+"]";  System.out.println(RESULT); :};

arregloInd ::= ident:a aperturaC INTEGER_LITERAL:b cerraduraC equivalente grupoArreglo:c {: RESULT = a+" = [" +b.toString()+"] = " + c;  System.out.println(RESULT); :};

returnD ::= returnC ident:a {: RESULT = "return " + a; System.out.println(RESULT);:}
            | returnC INTEGER_LITERAL:a {: RESULT = "return " + a.toString(); System.out.println(RESULT);:}
            | returnC FLOAT_LITERAL:a {: RESULT = "return " + a.toString(); System.out.println(RESULT);:}
            ;

print ::= printC aperturaP STRING_LITERAL:a cerraduraP {: RESULT = "print(" + a + ")"; System.out.println(RESULT);:};
input ::= inputC aperturaP ident:a cerraduraP {: RESULT = "input(" + a + ")"; System.out.println(RESULT);:};

param ::= param:a coma param:b              {: RESULT = a+","+b; System.out.println(RESULT); :}
         |tipo:a ident:b                        {: RESULT = a+" "+b; System.out.println(RESULT); :}
        ;

listaIdent ::= listaIdent:a coma listaIdent:b {: RESULT = a+","+b; System.out.println(RESULT); :}
                |ident:a                      {: RESULT = a; System.out.println(RESULT); :}
                ;

funcionAsig ::= ident:a aperturaP listaIdent:b cerraduraP {: RESULT = a+"("+b+")"; System.out.println(RESULT); :}
                |ident:a aperturaP cerraduraP        {: RESULT = a+"()"; System.out.println(RESULT); :}
                ;

variable ::= tipo ident;

variableAsig --> variable equivalente agrupacionVariable;

agrupacionVariable ::= funcionAsig 
                       | caracter 
                       | STRING_LITERAL 
                       | ident
                       ;
//(variableNum | variableB)

//Agrupaciones
tipo ::= string
        |INT
        |CHAR
        |FLOAT
        |BOOL
        ;

tipoArreglo ::= tipoNum 
              |CHAR
              |STRING
              ;

tipoNum ::=  INT
            |FLOAT
            ;
    
tipoFuncion ::=  tipoNum
                |bool
                ;

operacionArit ::= suma 
                |resta 
                |division
                |multiplicacion 
                |modulo 
                |potencia
                ;

operacionRac ::= menor 
                |mayor 
                |menorIgual 
                |mayorIgual 
                |diferente 
                |igual
                ;

operacionLog ::= diferente
                |igual 
                |conjuncion 
                |disyuncion
                ;

