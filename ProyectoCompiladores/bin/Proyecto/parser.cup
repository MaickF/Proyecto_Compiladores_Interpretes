package Proyecto;

/* Simple +/-/* expression language; parser evaluates constant expressions on the fly*/
import java_cup.runtime.*;

parser code {:
    // Connect this parser to a scanner!
    Lexer lex;

    @SuppressWarnings("deprecation")
    public parser(Lexer lex){
        this.lex = lex;
        this.symbolFactory = new DefaultSymbolFactory();
    }
:}

/* define how to connect to the scanner! */
init with {: :};
scan with {: return lex.next_token(); :};

/* Terminals (tokens returned by the scanner). */
terminal            BOOLEAN, BREAK, INT, FLOAT, CHAR;
terminal            STRING_LITERAL, LBLOQUE, RBLOQUE, STRING;
terminal            SEMI, UMINUS, LPAREN, RPAREN;
terminal            aperturaB, cerraduraB, aperturaC, cerraduraC, aperturaP, cerraduraP, comentarioL;
terminal            comentApert, comentCerrad, finalExpre, True, False;
terminal            letra, ident, caracter, bool;
terminal            menor, mayor, menorIgual, mayorIgual, diferente;
terminal            aumento, equivalente, igual, suma, decremento, multiplicacion, resta, negacion, division, modulo, potencia, conjuncion, disyuncion;
terminal            coma, punto, mainC, forC, doC, whileC, ifC, elseC, elifC, inputC, returnC, printC, inC;
terminal            NUMBER;
terminal            INTEGER_LITERAL;
terminal            FLOAT_LITERAL;

/* Non terminals */
non terminal            expr_list;
non terminal            expr;      // used to store evaluated subexpressions
non terminal operando, operacionNum, operacionNumSim;
non terminal tipoFuncion, tipoNum, operacionArit, operacionLog, operacionRac;
non terminal grupoArreglo, lista, arregloSim, arregloAsig, arregloInd;
non terminal returnD, input, print, param, funcionAsig, listaIdent, tipoVarArr;
non terminal variableAsig, variable,agrupacionVariable, declaracion;


/* Precedences */
precedence left suma, resta;
precedence left multiplicacion, division, modulo;
precedence left potencia;

precedence left coma;
//precedence left operacionArit;

start with declaracion;

/* The grammar rules */


expr      ::= expr:e1 suma expr:e2               {: RESULT = e1+"+"+e2; System.out.println(RESULT); :}
             | expr:e1 resta expr:e2             {: RESULT = e1+"-"+e2;   System.out.println(RESULT); :}
             | expr:e1 multiplicacion expr:e2    {: RESULT = e1+"*"+e2;     System.out.println(RESULT); :}
             | INTEGER_LITERAL:n	             {: RESULT = n.toString(); System.out.println(RESULT); :}
             ;
operando ::=  INTEGER_LITERAL:a {: RESULT = a; System.out.println(RESULT); :}
            | FLOAT_LITERAL:a {: RESULT = a; System.out.println(RESULT); :}
            | ident:a {: RESULT = a; System.out.println(RESULT); :}
            | funcionAsig:a {: RESULT = a; System.out.println(RESULT); :}
            ;

operacionNumSim ::= operando:a operacionArit:b operando:c {: RESULT = a+" "+b+" "+c; System.out.println(RESULT); :};

operacionNum ::= operacionNum:a operacionArit:b operando:c {: RESULT = a+" "+b+" "+c; System.out.println(RESULT); :}
                | operacionNumSim:a {: RESULT = a; System.out.println(RESULT); :}
                ;
/*
variableNum ::= tipoNum:a ident:b equivalente:c INTEGER_LITERAL:d {: RESULT = a+" "+b+" "+c+" "+d; System.out.println(RESULT); :};
            | tipoNum:a ident:b equivalente:c FLOAT_LITERAL:d {: RESULT = a+" "+b+" "+c+" "+d; System.out.println(RESULT); :};
            | tipoNum:a ident:b equivalente:c operacionNum:d {: RESULT = a+" "+b+" "+c+" "+d; System.out.println(RESULT); :};
            | tipoNum:a ident:b equivalente:c ident:d {: RESULT = a+" "+b+" "+c+" "+d; System.out.println(RESULT); :};
*/
lista ::= lista:l1 coma lista:l2              {: RESULT = l1+","+l2; System.out.println(RESULT); :}
         |grupoArreglo:n                        {: RESULT = n; System.out.println(RESULT); :}
        ;

grupoArreglo ::= INTEGER_LITERAL {: RESULT = "prueba1"; :}
                |FLOAT_LITERAL {: RESULT = "prueba2"; :}
                |caracter {: RESULT = "prueba3"; :}
                |STRING_LITERAL {: RESULT = "prueba4"; :}
                ;

arregloSim ::= tipoVarArr ident:a aperturaC INTEGER_LITERAL:b cerraduraC {: RESULT = "tipo "+a+" ["+b.toString()+"]"; System.out.println(RESULT);:};

arregloAsig ::= arregloSim:a equivalente aperturaC lista:b cerraduraC {: RESULT = a+" = [" +b+"]";  System.out.println(RESULT); :};

arregloInd ::= ident:a aperturaC INTEGER_LITERAL:b cerraduraC equivalente grupoArreglo:c {: RESULT = a+" = [" +b.toString()+"] = " + c;  System.out.println(RESULT); :};

returnD ::= returnC ident:a {: RESULT = "return " + a; System.out.println(RESULT);:}
            | returnC INTEGER_LITERAL:a {: RESULT = "return " + a.toString(); System.out.println(RESULT);:}
            | returnC FLOAT_LITERAL:a {: RESULT = "return " + a.toString(); System.out.println(RESULT);:}
            ;

print ::= printC aperturaP STRING_LITERAL:a cerraduraP {: RESULT = "print(" + a + ")"; System.out.println(RESULT);:};
input ::= inputC aperturaP ident:a cerraduraP {: RESULT = "input(" + a + ")"; System.out.println(RESULT);:};

param ::= param:a coma param:b              {: RESULT = a+","+b; System.out.println(RESULT); :}
         |tipoVarArr:a ident:b                        {: RESULT = a+" "+b; System.out.println(RESULT); :}
         |BOOLEAN:a ident:b                        {: RESULT = a+" "+b; System.out.println(RESULT); :}
        ;

listaIdent ::= listaIdent:a coma listaIdent:b {: RESULT = a+","+b; System.out.println(RESULT); :}
                |ident:a                      {: RESULT = a; System.out.println(RESULT); :}
                ;

funcionAsig ::= ident:a aperturaP listaIdent:b cerraduraP {: RESULT = a+"("+b+")"; System.out.println(RESULT); :}
                |ident:a aperturaP cerraduraP        {: RESULT = a+"()"; System.out.println(RESULT); :}
                ;

variable ::= tipoVarArr:a ident:b {: RESULT = a+ " " +b; System.out.println(RESULT); :}
            |BOOLEAN:a ident:b {: RESULT = a+ " " +b; System.out.println(RESULT); :}
            ;

declaracion ::= variable:a finalExpre {: RESULT = a+"$"; System.out.println(RESULT); :}
                |variableAsig:a finalExpre {: RESULT = a+"$"; System.out.println(RESULT); :}
                | operacionNum:a finalExpre {: RESULT = a+"$"; System.out.println(RESULT); :}
                //| operacionRac:a finalExpre {: RESULT = a+"$"; System.out.println(RESULT); :}
                |arregloSim:a finalExpre {: RESULT = a+"$"; System.out.println(RESULT); :}
                |arregloAsig:a finalExpre {: RESULT = a+"$"; System.out.println(RESULT); :}
                |arregloInd:a finalExpre {: RESULT = a+"$"; System.out.println(RESULT); :}
                |input:a finalExpre {: RESULT = a+"$"; System.out.println(RESULT); :}
                |print:a finalExpre {: RESULT = a+"$"; System.out.println(RESULT); :}
                ;


variableAsig ::= variable:a equivalente agrupacionVariable:b {: RESULT = a+" = "+b; System.out.println(RESULT); :};
//Agrupaciones

agrupacionVariable ::= funcionAsig:a  {: RESULT = a; System.out.println(RESULT); :}
                       | caracter:a  {: RESULT = a.toString(); System.out.println(RESULT); :}
                       | STRING_LITERAL:a  {: RESULT = a; System.out.println(RESULT); :}
                       | ident:a {: RESULT = a; System.out.println(RESULT); :}
                       ;
//(variableNum | variableB)

tipoVarArr ::= STRING
        |INT
        |CHAR
        |FLOAT
        ;

tipoNum ::=  INT
            |FLOAT
            ;
    
tipoFuncion ::=  tipoNum
                |bool
                ;

operacionArit ::= suma
                |resta 
                |division
                |multiplicacion 
                |modulo
                |potencia
                ;

operacionRac ::= menor 
                |mayor 
                |menorIgual 
                |mayorIgual 
                |diferente 
                |igual
                ;

operacionLog ::= diferente
                |igual 
                |conjuncion 
                |disyuncion
                ;

