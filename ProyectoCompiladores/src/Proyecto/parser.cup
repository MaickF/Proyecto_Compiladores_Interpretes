package Proyecto;

/* Simple +/-/* expression language; parser evaluates constant expressions on the fly*/
import java_cup.runtime.*;

parser code {:
    // Connect this parser to a scanner!
    Lexer lex;

    @SuppressWarnings("deprecation")
    public parser(Lexer lex){
        this.lex = lex;
        this.symbolFactory = new DefaultSymbolFactory();
    }
:}

/* define how to connect to the scanner! */
init with {: :};
scan with {: return lex.next_token(); :};

/* Terminals (tokens returned by the scanner). */
terminal            BOOL, BREAK, string, INT, FLOAT, CHAR;
terminal            STRING_LITERAL, LBLOQUE, RBLOQUE, STRING;
terminal            SEMI, UMINUS, LPAREN, RPAREN;
terminal            aperturaB, cerraduraB, aperturaC, cerraduraC, aperturaP, cerraduraP, comentarioL;
terminal            comentApert, comentCerrad, finalExpre, True, False;
terminal            letra, ident, caracter, bool;
terminal            menor, mayor, menorIgual, mayorIgual, diferente;
terminal            aumento, equivalente, igual, suma, decremento, multiplicacion, resta, negacion, division, modulo, potencia, conjuncion, disyuncion;
terminal            coma, punto, mainC, forC, doC, whileC, ifC, elseC, elifC, inputC, returnC;
terminal            NUMBER;
terminal            INTEGER_LITERAL;
terminal            FLOAT_LITERAL;

/* Non terminals */
non terminal            expr_list;
non terminal            expr;      // used to store evaluated subexpressions
non terminal tipo, tipoFuncion, tipoNum, operacionArit, operacionLog, operacionRac, lista, tipoArreglo;
non terminal grupoArreglo, arregloSim, arregloAsig, arregloInd;


/* Precedences */
precedence left suma, resta;
precedence left multiplicacion;

precedence left suma, resta;

precedence left coma;

start with arregloInd;

/* The grammar rules */


expr      ::= expr:e1 suma expr:e2               {: RESULT = e1+"+"+e2; System.out.println(RESULT); :}
             | expr:e1 resta expr:e2             {: RESULT = e1+"-"+e2;   System.out.println(RESULT); :}
             | expr:e1 multiplicacion expr:e2    {: RESULT = e1+"*"+e2;     System.out.println(RESULT); :}
             | INTEGER_LITERAL:n	             {: RESULT = n.toString(); System.out.println(RESULT); :}
             ;

lista ::= lista:l1 coma lista:l2              {: RESULT = l1+","+l2; System.out.println(RESULT); :}
         |grupoArreglo:n                        {: RESULT = n; System.out.println(RESULT); :}
        ;


grupoArreglo ::= INTEGER_LITERAL {: RESULT = "prueba1"; :}
                |FLOAT_LITERAL {: RESULT = "prueba2"; :}
                |caracter {: RESULT = "prueba3"; :}
                ;

arregloSim ::= tipoArreglo ident:a aperturaC INTEGER_LITERAL:b cerraduraC  {: RESULT = "tipo "+a+" ["+b.toString()+"]"; System.out.println(RESULT);:}; 

arregloAsig ::= arregloSim:a equivalente aperturaC lista:b cerraduraC {: RESULT = a+" = [" +b+"]";  System.out.println(RESULT); :};

arregloInd ::= ident:a aperturaC INTEGER_LITERAL:b cerraduraC equivalente grupoArreglo:c {: RESULT = a+" = [" +b.toString()+"] = " + c;  System.out.println(RESULT); :};

//Agrupaciones
tipo ::= string
        |INT
        |CHAR
        |FLOAT
        |bool
        ;

tipoArreglo ::= tipoNum 
              |CHAR
              |STRING
              ;

tipoNum ::=  INT
            |FLOAT
            ;
    
tipoFuncion ::=  tipoNum
                |bool
                ;

operacionArit ::= suma 
                |resta 
                |division
                |multiplicacion 
                |modulo 
                |potencia
                ;

operacionRac ::= menor 
                |mayor 
                |menorIgual 
                |mayorIgual 
                |diferente 
                |igual
                ;

operacionLog ::= diferente
                |igual 
                |conjuncion 
                |disyuncion
                ;

